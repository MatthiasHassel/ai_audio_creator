`gcui-art/suno-api` currently mainly implements the following APIs:

```bash
- `/api/generate`: Generate music
- `/v1/chat/completions`: Generate music - Call the generate API in a format 
  that works with OpenAI’s API.
- `/api/custom_generate`: Generate music (Custom Mode, support setting lyrics, 
  music style, title, etc.)
- `/api/generate_lyrics`: Generate lyrics based on prompt
- `/api/get`: Get music information based on the id. Use “,” to separate multiple 
    ids.  If no IDs are provided, all music will be returned.
- `/api/get_limit`: Get quota Info
- `/api/extend_audio`: Extend audio length
- `/api/clip`:  Get clip information based on ID passed as query parameter `id`
- `/api/concat`: Generate the whole song from extensions
```

I am using the api/generate method. Here are more details about this:

It will automatically fill in the lyrics.
2 audio files will be generated for each request, consuming a total of 10 credits.
`wait_audio` can be set to API mode:
• By default, it is set to `false`, which indicates the background mode. It will only return audio task information, and you will need to call the get API to retrieve detailed audio information.
• If set to `true`, it simulates synchronous mode. The API will wait for a maximum of 100s until the audio is generated, and will directly return the audio link and other information. Recommend using in GPTs and other agents.

Responses:

```json
[
  {
    "0": {
      "id": "string",
      "title": "string",
      "image_url": "string",
      "lyric": "string",
      "audio_url": "string",
      "video_url": "string",
      "created_at": "string",
      "model_name": "string",
      "status": "string",
      "gpt_description_prompt": "string",
      "prompt": "string",
      "type": "string",
      "tags": "string"
    },
    "1": {
      "id": "string",
      "title": "string",
      "image_url": "string",
      "lyric": "string",
      "audio_url": "string",
      "video_url": "string",
      "created_at": "string",
      "model_name": "string",
      "status": "string",
      "gpt_description_prompt": "string",
      "prompt": "string",
      "type": "string",
      "tags": "string"
    }
  }
]
```


Also the description of the api/get function:
Audio IDs, separated by commas. Leave blank to return a list of all music.

Responses:

```json
[
  {
    "0": {
      "id": "string",
      "title": "string",
      "image_url": "string",
      "lyric": "string",
      "audio_url": "string",
      "video_url": "string",
      "created_at": "string",
      "model_name": "string",
      "status": "string",
      "gpt_description_prompt": "string",
      "prompt": "string",
      "type": "string",
      "tags": "string"
    },
    "1": {
      "id": "string",
      "title": "string",
      "image_url": "string",
      "lyric": "string",
      "audio_url": "string",
      "video_url": "string",
      "created_at": "string",
      "model_name": "string",
      "status": "string",
      "gpt_description_prompt": "string",
      "prompt": "string",
      "type": "string",
      "tags": "string"
    }
  }
]
```


/api/clip 

Retrieve specific clip information using the provided clip ID as a query parameter.

Parameters: Clip ID (string)

Responses:
{
  "id": "string",
  "title": "string",
  "image_url": "string",
  "lyric": "string",
  "audio_url": "string",
  "video_url": "string",
  "created_at": "string",
  "model_name": "string",
  "status": "string",
  "gpt_description_prompt": "string",
  "prompt": "string",
  "type": "string",
  "tags": "string"
}


Schemas:
audio_info{
description:	
Audio Info

id*	[...]
title*	[...]
image_url*	[...]
lyric*	[...]
audio_url*	[...]
video_url*	[...]
created_at*	[...]
model_name*	[...]
status*	[...]
gpt_description_prompt*	[...]
prompt*	[...]
type*	[...]
tags*	[...]
}



Example Code:

import time
import requests

# replace your vercel domain
base_url = 'http://localhost:3000'


def custom_generate_audio(payload):
    url = f"{base_url}/api/custom_generate"
    response = requests.post(url, json=payload, headers={'Content-Type': 'application/json'})
    return response.json()


def extend_audio(payload):
    url = f"{base_url}/api/extend_audio"
    response = requests.post(url, json=payload, headers={'Content-Type': 'application/json'})
    return response.json()

def generate_audio_by_prompt(payload):
    url = f"{base_url}/api/generate"
    response = requests.post(url, json=payload, headers={'Content-Type': 'application/json'})
    return response.json()


def get_audio_information(audio_ids):
    url = f"{base_url}/api/get?ids={audio_ids}"
    response = requests.get(url)
    return response.json()


def get_quota_information():
    url = f"{base_url}/api/get_limit"
    response = requests.get(url)
    return response.json()

def get_clip(clip_id):
    url = f"{base_url}/api/clip?id={clip_id}"
    response = requests.get(url)
    return response.json()

def generate_whole_song(clip_id):
    payloyd = {"clip_id": clip_id}
    url = f"{base_url}/api/concat"
    response = requests.post(url, json=payload)
    return response.json()


if __name__ == '__main__':
    data = generate_audio_by_prompt({
        "prompt": "A popular heavy metal song about war, sung by a deep-voiced male singer, slowly and melodiously. The lyrics depict the sorrow of people after the war.",
        "make_instrumental": False,
        "wait_audio": False
    })

    ids = f"{data[0]['id']},{data[1]['id']}"
    print(f"ids: {ids}")

    for _ in range(60):
        data = get_audio_information(ids)
        if data[0]["status"] == 'streaming':
            print(f"{data[0]['id']} ==> {data[0]['audio_url']}")
            print(f"{data[1]['id']} ==> {data[1]['audio_url']}")
            break
        # sleep 5s
        time.sleep(5)
